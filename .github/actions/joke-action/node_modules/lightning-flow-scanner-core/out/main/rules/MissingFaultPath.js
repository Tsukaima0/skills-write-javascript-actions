"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingFaultPath = void 0;
const RuleCommon_1 = require("../models/RuleCommon");
const core = __importStar(require("../internals/internals"));
class MissingFaultPath extends RuleCommon_1.RuleCommon {
    constructor() {
        super({
            name: 'MissingFaultPath',
            label: 'Missing Fault Path',
            description: "At times, a flow may fail to execute a configured operation as intended. By default, the flow displays an error message to the user and notifies the admin who created the flow via email. However, you can customize this behavior by incorporating a Fault Path.",
            supportedTypes: [...core.FlowType.backEndTypes, ...core.FlowType.visualTypes],
            docRefs: [{ label: 'Flow Best Practices', path: 'https://help.salesforce.com/s/articleView?id=sf.flow_prep_bestpractices.htm&type=5' }],
            isConfigurable: false,
            autoFixable: false
        });
    }
    execute(flow) {
        const compiler = new core.Compiler();
        const results = [];
        const elementsWhereFaultPathIsApplicable = flow.elements.filter((node) => node instanceof core.FlowNode && ['recordLookups', 'recordDeletes', 'recordUpdates', 'recordCreates', 'waits', 'actionCalls'].includes(node.subtype)).map((e) => e.name);
        const visitCallback = (element) => {
            // Check if the element should have a fault path
            if (!element.connectors.find((connector) => connector.type === 'faultConnector') && elementsWhereFaultPathIsApplicable.includes(element.name)) {
                // Check if the element is part of another fault path
                if (!this.isPartOfFaultHandlingFlow(element, flow)) {
                    results.push(new core.ResultDetails(element));
                }
            }
        };
        // Use the core.Compiler for traversal
        compiler.traverseFlow(flow, flow.startReference, visitCallback);
        return new core.RuleResult(this, results);
    }
    isPartOfFaultHandlingFlow(element, flow) {
        const flowelements = flow.elements.filter(el => el instanceof core.FlowNode);
        for (const otherElement of flowelements) {
            if (otherElement !== element) {
                // Check if the otherElement has a faultConnector pointing to element
                if (otherElement.connectors.find((connector) => connector.type === 'faultConnector' && connector.reference === element.name)) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.MissingFaultPath = MissingFaultPath;
//# sourceMappingURL=MissingFaultPath.js.map