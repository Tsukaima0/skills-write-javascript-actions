"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingNullHandler = void 0;
const RuleCommon_1 = require("../models/RuleCommon");
const core = __importStar(require("../internals/internals"));
class MissingNullHandler extends RuleCommon_1.RuleCommon {
    constructor() {
        super({
            name: 'MissingNullHandler',
            label: 'Missing Null Handler',
            description: "When a Get Records operation doesn't find any data, it returns null. To ensure data validation, utilize a decision element on the operation result variable to check for a non-null result.",
            supportedTypes: [...core.FlowType.backEndTypes, ...core.FlowType.visualTypes],
            docRefs: [],
            isConfigurable: false,
            autoFixable: false
        });
    }
    execute(flow) {
        const getOperations = ['recordLookups'];
        const getOperationElements = flow.elements.filter(node => node.metaType === 'node' && getOperations.includes(node.subtype));
        const decisionElements = flow.elements.filter(node => node.metaType === 'node' && node.subtype === 'decisions');
        const getOperationsWithoutNullHandler = [];
        for (const getElement of getOperationElements) {
            const elementName = getElement.name;
            let nullCheckFound = false;
            let resultReferences = [];
            if (getElement.element['storeOutputAutomatically']) {
                resultReferences = [elementName];
            }
            else if (getElement.element['outputReference']) {
                resultReferences = getElement.element['outputReference'];
            }
            else if (getElement.element['outputAssignments']) {
                const outputAssignments = getElement.element['outputAssignments'];
                for (const assignment of outputAssignments) {
                    resultReferences.push(assignment.assignToReference);
                }
            }
            for (const el of decisionElements) {
                const rules = el.element['rules'];
                for (const rule of rules) {
                    for (const condition of rule.conditions) {
                        let referenceFound = false;
                        let isNullOperator = false;
                        let checksIfFalse = false;
                        if (condition.leftValueReference && condition.leftValueReference.length > 0) {
                            let valueReference = condition.leftValueReference;
                            for (let ref of resultReferences) {
                                referenceFound = ref.includes(valueReference);
                                if (referenceFound) {
                                    break;
                                }
                            }
                        }
                        if (condition.operator && condition.operator.length > 0) {
                            let operator = condition.operator;
                            isNullOperator = (operator === 'IsNull');
                        }
                        if (condition.rightValue && condition.rightValue.length > 0 && condition.rightValue.booleanValue && condition.rightValue.booleanValue.length > 0) {
                            let rightValue = condition.rightValue.booleanValue;
                            checksIfFalse = (rightValue.toLowerCase() === 'false');
                        }
                        if (referenceFound && isNullOperator && checksIfFalse) {
                            nullCheckFound = true;
                        }
                    }
                }
            }
            if (!nullCheckFound) {
                getOperationsWithoutNullHandler.push(getElement);
            }
        }
        let results = [];
        for (const det of getOperationsWithoutNullHandler) {
            results.push(new core.ResultDetails(det));
        }
        return new core.RuleResult(this, results);
    }
}
exports.MissingNullHandler = MissingNullHandler;
//# sourceMappingURL=MissingNullHandler.js.map