"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DuplicateDMLOperation = void 0;
const RuleCommon_1 = require("../models/RuleCommon");
const core = __importStar(require("../internals/internals"));
class DuplicateDMLOperation extends RuleCommon_1.RuleCommon {
    constructor() {
        super({
            name: "DuplicateDMLOperation",
            label: "Duplicate DML Operation",
            description: "When the flow executes database changes or actions between two screens, it's important to prevent users from navigating back between screens. Failure to do so may result in duplicate database operations being performed within the flow.",
            supportedTypes: core.FlowType.visualTypes,
            docRefs: [],
            isConfigurable: false,
            autoFixable: false,
        });
    }
    execute(flow) {
        const flowElements = flow.elements.filter((node) => node instanceof core.FlowNode);
        const processedElementIndexes = [];
        const unconnectedElementIndexes = [];
        const DuplicateDMLOperations = [];
        const startingNode = this.findStart(flow);
        if (!startingNode || startingNode === -1) {
            throw "Can not find starting element";
        }
        let dmlFlag = false;
        let indexesToProcess = [startingNode];
        do {
            indexesToProcess = indexesToProcess.filter((index) => !processedElementIndexes.includes(index));
            if (indexesToProcess.length > 0) {
                for (const [index, element] of flowElements.entries()) {
                    if (indexesToProcess.includes(index)) {
                        const references = [];
                        if (element.connectors && element.connectors.length > 0) {
                            for (const connector of element.connectors) {
                                if (connector.reference) {
                                    references.push(connector.reference);
                                }
                            }
                        }
                        dmlFlag = this.flagDML(element, dmlFlag);
                        if (references.length > 0) {
                            const elementsByReferences = flowElements.filter((element) => references.includes(element.name));
                            for (const nextElement of elementsByReferences) {
                                const nextIndex = flowElements.findIndex((element) => nextElement.name === element.name);
                                if ("screens" === nextElement.subtype) {
                                    if (dmlFlag &&
                                        nextElement.element["allowBack"] &&
                                        nextElement.element["allowBack"] == "true" &&
                                        nextElement.element["showFooter"] == "true") {
                                        DuplicateDMLOperations.push(nextElement);
                                    }
                                }
                                if (!processedElementIndexes.includes(nextIndex)) {
                                    indexesToProcess.push(nextIndex);
                                }
                            }
                        }
                        processedElementIndexes.push(index);
                    }
                }
            }
            else {
                // skip unconnected elements
                for (const index of flowElements.keys()) {
                    if (!processedElementIndexes.includes(index)) {
                        unconnectedElementIndexes.push(index);
                    }
                }
            }
        } while (processedElementIndexes.length + unconnectedElementIndexes.length <
            flowElements.length);
        let results = [];
        for (const det of DuplicateDMLOperations) {
            results.push(new core.ResultDetails(det));
        }
        return new core.RuleResult(this, results);
    }
    flagDML(element, dmlFlag) {
        const dmlStatementTypes = [
            "recordDeletes",
            "recordUpdates",
            "recordCreates",
        ];
        if (dmlStatementTypes.includes(element.subtype)) {
            return true;
        }
        else if (dmlFlag === true &&
            element.subtype === "screens" &&
            element.element["allowBack"] &&
            element.element["allowBack"] == "true") {
            return false;
        }
        else {
            return dmlFlag;
        }
    }
    findStart(flow) {
        const flowElements = flow.elements.filter((node) => node instanceof core.FlowNode);
        let start;
        if (flow.startElementReference) {
            start = flowElements.findIndex((n) => {
                return n.name == flow.startElementReference;
            });
        }
        else {
            start = flowElements.findIndex((n) => {
                return n.subtype === "start";
            });
        }
        return start;
    }
}
exports.DuplicateDMLOperation = DuplicateDMLOperation;
//# sourceMappingURL=DuplicateDMLOperation.js.map