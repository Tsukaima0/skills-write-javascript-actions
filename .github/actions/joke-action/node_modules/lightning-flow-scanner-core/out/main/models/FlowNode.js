"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowNode = void 0;
const FlowElementConnector_1 = require("./FlowElementConnector");
const FlowElement_1 = require("./FlowElement");
class FlowNode extends FlowElement_1.FlowElement {
    constructor(provName, subtype, element) {
        super('node', subtype, element);
        this.connectors = [];
        let nodeName = subtype === 'start' ? 'flowstart' : provName;
        this.name = nodeName;
        const connectors = this.getConnectors(subtype, element);
        this.connectors = connectors;
        this.locationX = element["locationX"];
        this.locationY = element["locationY"];
    }
    getConnectors(subtype, element) {
        var _a;
        if (subtype === 'start') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (Array.isArray(element.scheduledPaths)) {
                for (const asyncElement of element === null || element === void 0 ? void 0 : element.scheduledPaths) {
                    if (asyncElement.connector) {
                        connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', asyncElement.connector, {
                            childName: (_a = asyncElement === null || asyncElement === void 0 ? void 0 : asyncElement.name) !== null && _a !== void 0 ? _a : 'AsyncAfterCommit',
                            childOf: 'scheduledPaths'
                        }));
                    }
                }
            }
            else {
                if (element.scheduledPaths) {
                    connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.scheduledPaths, {
                        childName: element.scheduledPaths.name,
                        childOf: 'scheduledPaths'
                    }));
                }
            }
            return connectors;
        }
        else if (subtype === 'decisions') {
            const connectors = [];
            if (element.defaultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('defaultConnector', element.defaultConnector, {}));
            }
            if (element.rules) {
                if (Array.isArray(element.rules)) {
                    for (const rule of element.rules) {
                        if (rule.connector) {
                            connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', rule.connector, {
                                childName: rule.name,
                                childOf: 'rules'
                            }));
                        }
                    }
                }
                else {
                    if (element.rules.connector) {
                        connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.rules.connector, {
                            childName: element.rules.name,
                            childOf: 'rules'
                        }));
                    }
                }
            }
            return connectors;
        }
        else if (subtype === 'assignments') {
            return element.connector ? [new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {})] : [];
        }
        else if (subtype === 'loops') {
            const connectors = [];
            if (element.nextValueConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('nextValueConnector', element.nextValueConnector, {}));
            }
            if (element.noMoreValuesConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('noMoreValuesConnector', element.noMoreValuesConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'actionCalls') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'waits') {
            const connectors = [];
            if (element.defaultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('defaultConnector', element.defaultConnector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            if (Array.isArray(element.waitEvents)) {
                for (const waitEvent of element.waitEvents) {
                    if (waitEvent.connector) {
                        connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', waitEvent.connector, {
                            childName: waitEvent.name,
                            childOf: 'waitEvents'
                        }));
                    }
                }
            }
            return connectors;
        }
        else if (subtype === 'recordCreates') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'recordDeletes') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'recordLookups') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'recordUpdates') {
            const connectors = [];
            if (element.connector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {}));
            }
            if (element.faultConnector) {
                connectors.push(new FlowElementConnector_1.FlowElementConnector('faultConnector', element.faultConnector, {}));
            }
            return connectors;
        }
        else if (subtype === 'subflows') {
            return element.connector ? [new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {})] : [];
        }
        else if (subtype === 'screens') {
            return element.connector ? [new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {})] : [];
        }
        else {
            return element.connector ? [new FlowElementConnector_1.FlowElementConnector('connector', element.connector, {})] : [];
        }
    }
}
exports.FlowNode = FlowNode;
//# sourceMappingURL=FlowNode.js.map