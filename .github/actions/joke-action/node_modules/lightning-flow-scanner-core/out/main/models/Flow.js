"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flow = void 0;
const FlowNode_1 = require("./FlowNode");
const FlowMetadata_1 = require("./FlowMetadata");
const FlowVariable_1 = require("./FlowVariable");
const path_browserify_1 = __importDefault(require("path-browserify"));
const FlowResource_1 = require("./FlowResource");
class Flow {
    constructor(path, data) {
        this.flowVariables = [
            "choices",
            "constants",
            "dynamicChoiceSets",
            "formulas",
            "variables",
        ];
        this.flowResources = ["textTemplates", "stages"];
        this.flowMetadata = [
            "description",
            "apiVersion",
            "processMetadataValues",
            "processType",
            "interviewLabel",
            "label",
            "status",
            "runInMode",
            "startElementReference",
            "isTemplate",
            "fullName",
            "timeZoneSidKey",
            "isAdditionalPermissionRequiredToRun",
            "migratedFromWorkflowRuleName",
            "triggerOrder",
            "environments",
            "segment",
        ];
        this.flowNodes = [
            "actionCalls",
            "apexPluginCalls",
            "assignments",
            "collectionProcessors",
            "decisions",
            "loops",
            "orchestratedStages",
            "recordCreates",
            "recordDeletes",
            "recordLookups",
            "recordUpdates",
            "recordRollbacks",
            "screens",
            "start",
            "steps",
            "subflows",
            "waits",
        ];
        this.fsPath = path_browserify_1.default.resolve(path);
        let flowName = path_browserify_1.default.basename(path_browserify_1.default.basename(this.fsPath), path_browserify_1.default.extname(this.fsPath));
        if (flowName.includes(".")) {
            flowName = flowName.split(".")[0];
        }
        this.name = flowName;
        if (data) {
            if (data.Flow) {
                this.xmldata = data.Flow;
            }
            else
                this.xmldata = data;
            this.preProcessNodes();
        }
    }
    preProcessNodes() {
        this.label = this.xmldata.label;
        this.interviewLabel = this.xmldata.interviewLabel;
        this.processType = this.xmldata.processType;
        this.processMetadataValues = this.xmldata.processMetadataValues;
        this.startElementReference = this.xmldata.startElementReference;
        this.start = this.xmldata.start;
        this.status = this.xmldata.status;
        this.type = this.xmldata.processType;
        const allNodes = [];
        for (const nodeType in this.xmldata) {
            // skip xmlns url
            // if (nodeType == "@xmlns") {
            //   continue;
            // }
            let data = this.xmldata[nodeType];
            if (this.flowMetadata.includes(nodeType)) {
                if (Array.isArray(data)) {
                    for (const node of data) {
                        allNodes.push(new FlowMetadata_1.FlowMetadata(nodeType, node));
                    }
                    for (const node of data) {
                    }
                }
                else {
                    allNodes.push(new FlowMetadata_1.FlowMetadata(nodeType, data));
                }
            }
            else if (this.flowVariables.includes(nodeType)) {
                if (Array.isArray(data)) {
                    for (const node of data) {
                        allNodes.push(new FlowVariable_1.FlowVariable(node.name, nodeType, node));
                    }
                }
                else {
                    allNodes.push(new FlowVariable_1.FlowVariable(data.name, nodeType, data));
                }
            }
            else if (this.flowNodes.includes(nodeType)) {
                if (Array.isArray(data)) {
                    for (const node of data) {
                        allNodes.push(new FlowNode_1.FlowNode(node.name, nodeType, node));
                    }
                }
                else {
                    allNodes.push(new FlowNode_1.FlowNode(data.name, nodeType, data));
                }
            }
            else if (this.flowResources.includes(nodeType)) {
                if (Array.isArray(data)) {
                    for (const node of data) {
                        allNodes.push(new FlowResource_1.FlowResource(node.name, nodeType, node));
                    }
                }
                else {
                    allNodes.push(new FlowResource_1.FlowResource(data.name, nodeType, data));
                }
            }
        }
        this.elements = allNodes;
        this.startReference = this.findStart();
    }
    findStart() {
        let start = "";
        const flowElements = this.elements.filter((node) => node instanceof FlowNode_1.FlowNode);
        if (this.startElementReference) {
            start = this.startElementReference;
        }
        else if (flowElements.find((n) => {
            return n.subtype === "start";
        })) {
            let startElement = flowElements.find((n) => {
                return n.subtype === "start";
            });
            start = startElement.connectors[0]["reference"];
        }
        return start;
    }
}
exports.Flow = Flow;
//# sourceMappingURL=Flow.js.map